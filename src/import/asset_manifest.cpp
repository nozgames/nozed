//
//  NoZ Game Engine - Copyright(c) 2025 NoZ Games, LLC
//

// @STL

#include "asset_manifest.h"

namespace fs = std::filesystem;

const char* ASSET_MANIFEST_HEADER =
    "//\n"
    "// Auto-generated asset header - DO NOT EDIT MANUALLY\n"
    "// Generated by NoZ Game Engine Asset Importer\n"
    "//\n\n";

struct AssetEntry {
    AssetData* asset;
    std::string var_name;
    AssetType type;
    std::vector<const Name*> names;
};

struct BoneIndex {
    std::string skeleton_name;
    std::string name;
    int index;
    bool last;
};

struct ManifestGenerator {
    std::map<const Name*, std::string> names;
    std::set<AssetType> types;
    std::vector<BoneIndex> bones;
    std::vector<AssetEntry> assets;
    fs::path source_path;
    fs::path target_path;
    Props* config;
};

static void SortAssets(ManifestGenerator& generator);
static void GenerateHeader(ManifestGenerator& generator);
static void GenerateSource(ManifestGenerator& generator);

static std::string GetNameVar(const Name* name) {
    std::string result = name->value;
    Uppercase(result.data(), (u32)result.size());
    Replace(result.data(), (u32)result.size(), '/', '_');
    Replace(result.data(), (u32)result.size(), '.', '_');
    Replace(result.data(), (u32)result.size(), ' ', '_');
    return result;
}

static AssetType ReadAssetHeader(AssetData* ea, ManifestGenerator& generator, std::vector<const Name*>& out_names) {
    fs::path path = g_editor.output_dir / ToString(ea->importer->type) / ea->name->value;
    Stream* stream = LoadStream(nullptr, path);
    if (!stream)
        return ASSET_TYPE_UNKNOWN;

    AssetHeader header;
    if (ReadAssetHeader(stream, &header) && header.names > 0){
        if (!IsValidAssetType(header.type))
            return ASSET_TYPE_UNKNOWN;

        const Name** name_table = ReadNameTable(header, stream);
        if (name_table) {
            for (uint32_t i = 0; i < header.names; i++) {
                generator.names[name_table[i]] = GetNameVar(name_table[i]);
                out_names.push_back(name_table[i]);
            }

            if (header.type == ASSET_TYPE_SKELETON) {
                std::string skeleton_name = GetSafeFilename(path.filename().string().c_str()).replace_extension("").string();
                Uppercase(skeleton_name.data(), (u32)skeleton_name.size());

                for (uint32_t i = 0; i < header.names; i++) {
                    std::string bone_name = name_table[i]->value;
                    Uppercase(bone_name.data(), (u32)bone_name.size());
                    generator.bones.push_back({
                        .skeleton_name = skeleton_name,
                        .name = bone_name,
                        .index = (int)i,
                        .last = i == header.names - 1
                    });
                }
            }
        }
    }

    Free(stream);

    generator.types.insert(header.type);

    return header.type;
}

static bool ReadAsset(u32 item_index, void* item_ptr, void* user_data) {
    (void)item_index;

    assert(item_ptr);
    AssetData* a = (AssetData*)item_ptr;
    if (a->editor_only)
        return true;

    ManifestGenerator& generator = *(ManifestGenerator*)user_data;

    std::vector<const Name*> names;
    AssetType asset_type = ReadAssetHeader(a, generator, names);
    if (asset_type == ASSET_TYPE_UNKNOWN)
        return true;

    const char* type_name = ToString(asset_type);
    if (!type_name)
        return true;

    std::string var_name = std::string(type_name) + "_" + a->name->value;
    Uppercase(var_name.data(), (u32)var_name.size());

    generator.assets.push_back({
        .asset = a,
        .var_name = var_name,
        .type = asset_type,
        .names = std::move(names)
    });

    return true;
}

static void SortAssets(ManifestGenerator& generator) {
    std::ranges::sort(generator.assets.begin(), generator.assets.end(), [](const AssetEntry& a, const AssetEntry& b) {
        return Compare(a.asset->name->value, b.asset->name->value);
    });
}

bool GenerateAssetManifest(const fs::path& source_path, const fs::path& target_path, Props* config)
{
    (void)target_path;

    if (fs::exists(source_path) && !fs::is_directory(source_path))
        return false;

    ManifestGenerator generator = {};
    generator.source_path = source_path;
    generator.target_path = target_path;
    generator.config = config;

    try
    {
        Enumerate(g_editor.asset_allocator, ReadAsset, &generator);
    }
    catch (const std::exception&)
    {
        return false;
    }

    for (const std::string& name_str : config->GetKeys("names"))
    {
        const Name* name = GetName(name_str.c_str());
        generator.names[name] = GetNameVar(name);
    }

    SortAssets(generator);
    GenerateHeader(generator);
    GenerateSource(generator);
    return true;
}

static void GenerateSource(ManifestGenerator& generator)
{
    Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

    fs::path header_path = generator.target_path;
    header_path.replace_extension(".h");

    WriteCSTR(stream, ASSET_MANIFEST_HEADER);
    WriteCSTR(stream, "#include <noz/noz.h>\n");
    WriteCSTR(stream, "#include \"%s\"\n\n", header_path.filename().string().c_str());

    fs::path build_path = generator.target_path.filename();
    build_path.replace_extension("");

    WriteCSTR(stream, "#ifdef NDEBUG\n");
    WriteCSTR(stream, "#include \"%s\"\n", (build_path.string() + "_build.cpp").c_str());
    WriteCSTR(stream, "#endif\n");

    for (AssetType asset_type : generator.types) {
        const char* type_name = ToString(asset_type);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @%s\n", type_name);

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            WriteCSTR(stream, "%s* %s = nullptr;\n", type_name, asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "const Name* NAME_%s = nullptr;\n", kv.second.c_str());

    WriteCSTR(stream,
        "\n"
        "// @path\n");

    for (AssetEntry& asset : generator.assets)
        WriteCSTR(stream, "const Name* PATH_%s = nullptr;\n", asset.var_name.c_str());

    WriteCSTR(stream,
        "\n"
        "// @load\n"
        "bool LoadAssets(Allocator* allocator)\n"
        "{\n");

    WriteCSTR(stream, "    // @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "    NAME_%s = GetName(\"%s\");\n", kv.second.c_str(), kv.first->value);

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "    // @path\n");
    for (AssetEntry& asset : generator.assets)
        WriteCSTR(stream, "    PATH_%s = GetName(\"%s\");\n", asset.var_name.c_str(), asset.asset->name->value);

    for (AssetType asset_type : generator.types) {
        const char* type_name = ToString(asset_type);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", type_name);

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            WriteCSTR(stream, "    NOZ_LOAD_%s(allocator, PATH_%s, %s);\n", type_name_upper.c_str(), asset.var_name.c_str(), asset.var_name.c_str());
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    static %s* _%s[] = {\n", type_name, type_name_upper.c_str());

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            WriteCSTR(stream, "        %s,\n", asset.var_name.c_str());
        }

        WriteCSTR(stream, "        nullptr\n");
        WriteCSTR(stream, "    };\n");
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    %s = _%s;\n", type_name_upper.c_str(), type_name_upper.c_str());
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "    return true;\n");
    WriteCSTR(stream, "}\n");

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @unload\n");
    WriteCSTR(stream, "void UnloadAssets()\n");
    WriteCSTR(stream, "{");

    for (AssetType asset_type : generator.types) {
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", ToString(asset_type));

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            WriteCSTR(stream, "    Free(%s);\n",asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "}\n");

    WriteCSTR(stream, "\n#ifdef NOZ_EDITOR\n");
    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "void HotloadAsset(const Name* incoming_name, AssetType incoming_type)\n");
    WriteCSTR(stream, "{");

    for (AssetType asset_type : generator.types) {
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", ToString(asset_type));

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            std::string type_name_upper = ToString(asset.type);
            Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

            WriteCSTR(stream, "    NOZ_RELOAD_%s(PATH_%s, %s);\n", type_name_upper.c_str(), asset.var_name.c_str(), asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "}\n");
    WriteCSTR(stream, "\n#endif // NOZ_EDITOR\n");

    SaveStream(stream, generator.target_path);

    Free(stream);
}

static void GenerateHeader(ManifestGenerator& generator) {
    Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

    WriteCSTR(stream, ASSET_MANIFEST_HEADER);
    WriteCSTR(stream,
        "#pragma once\n\n"
        "#include <noz/core_assets.h>\n");

    for (AssetType asset_type : generator.types) {
        const char* type_name = ToString(asset_type);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @%s\n", type_name);

        for (AssetEntry& asset : generator.assets) {
            if (asset.type != asset_type)
                continue;

            WriteCSTR(stream, "extern %s* %s;\n", type_name, asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "extern const Name* NAME_%s;\n", kv.second.c_str());

    if (!generator.bones.empty()) {
        WriteCSTR(stream, "\n");
        for (BoneIndex& bone_index : generator.bones) {
            if (bone_index.index == 0)
                WriteCSTR(stream, "\n// @BONE_%s\n", bone_index.skeleton_name.c_str());

            WriteCSTR(stream, "constexpr int BONE_%s_%s = %d;\n", bone_index.skeleton_name.c_str(), bone_index.name.c_str(), bone_index.index);

            if (bone_index.last)
                WriteCSTR(stream, "constexpr int BONE_%s_COUNT = %d;\n", bone_index.skeleton_name.c_str(), bone_index.index + 1);
        }
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "\nextern bool LoadAssets(Allocator* allocator);\n");
    WriteCSTR(stream, "extern void UnloadAssets();\n");
    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "#ifdef NOZ_EDITOR\n");
    WriteCSTR(stream, "extern void HotloadAsset(const Name* incoming_name, AssetType incoming_type);\n");
    WriteCSTR(stream, "#endif\n");

    fs::path header_path = generator.target_path;
    header_path.replace_extension(".h");
    SaveStream(stream, header_path);

    Free(stream);
}

