//
//  NoZ Game Engine - Copyright(c) 2025 NoZ Games, LLC
//

// @STL

#include "asset_manifest.h"

namespace fs = std::filesystem;

const char* ASSET_MANIFEST_HEADER =
    "//\n"
    "// Auto-generated asset header - DO NOT EDIT MANUALLY\n"
    "// Generated by NoZ Game Engine Asset Importer\n"
    "//\n\n";

struct AssetEntry
{
    EditorAsset* asset;
    std::string var_name;
    uint32_t signature;
    std::vector<const Name*> names;
};

struct BoneIndex
{
    std::string skeleton_name;
    std::string name;
    int index;
};

struct ManifestGenerator
{
    std::map<const Name*, std::string> names;
    std::set<AssetSignature> signatures;
    std::vector<BoneIndex> bones;
    std::vector<AssetEntry> assets;
    fs::path source_path;
    fs::path target_path;
    Props* config;
};

static void SortAssets(ManifestGenerator& generator);
static void GenerateHeader(ManifestGenerator& generator);
static void GenerateSource(ManifestGenerator& generator);

static std::string GetNameVar(const Name* name)
{
    std::string result = name->value;
    Uppercase(result.data(), (u32)result.size());
    Replace(result.data(), (u32)result.size(), '/', '_');
    Replace(result.data(), (u32)result.size(), '.', '_');
    Replace(result.data(), (u32)result.size(), ' ', '_');
    return result;
}

static AssetSignature ReadAssetHeader(EditorAsset* ea, ManifestGenerator& generator, std::vector<const Name*>& out_names)
{
    fs::path path = g_editor.output_dir / GetTypeNameFromSignature(ea->importer->signature) / ea->name->value;
    Stream* stream = LoadStream(nullptr, path);
    if (!stream)
        return ASSET_SIGNATURE_UNKNOWN;

    AssetHeader header;
    if (ReadAssetHeader(stream, &header) && header.names > 0)
    {
        if (!IsValidSignature(header.signature))
            return ASSET_SIGNATURE_UNKNOWN;

        const Name** name_table = ReadNameTable(header, stream);
        if (name_table)
        {
            for (uint32_t i = 0; i < header.names; i++)
            {
                generator.names[name_table[i]] = GetNameVar(name_table[i]);
                out_names.push_back(name_table[i]);
            }

            if (header.signature == ASSET_SIGNATURE_SKELETON)
            {
                std::string skeleton_name = GetSafeFilename(path.filename().string().c_str()).replace_extension("").string();
                Uppercase(skeleton_name.data(), (u32)skeleton_name.size());

                for (uint32_t i = 0; i < header.names; i++)
                {
                    std::string bone_name = name_table[i]->value;
                    Uppercase(bone_name.data(), (u32)bone_name.size());

                    BoneIndex bone_index;
                    bone_index.skeleton_name = skeleton_name;
                    bone_index.name = bone_name;
                    bone_index.index = (int)i;
                    generator.bones.push_back(bone_index);
                }
            }
        }
    }

    Free(stream);

    generator.signatures.insert(header.signature);

    return header.signature;
}

static bool ReadAsset(u32 item_index, void* item_ptr, void* user_data)
{
    (void)item_index;

    assert(item_ptr);
    EditorAsset* ea = (EditorAsset*)item_ptr;
    ManifestGenerator& generator = *(ManifestGenerator*)user_data;

    std::vector<const Name*> names;
    AssetSignature signature = ReadAssetHeader(ea, generator, names);
    if (signature == ASSET_SIGNATURE_UNKNOWN)
        return true;

    const char* type_name = GetTypeNameFromSignature(signature);
    if (!type_name)
        return true;

    std::string var_name = std::string(type_name) + "_" + ea->name->value;
    Uppercase(var_name.data(), (u32)var_name.size());

    generator.assets.push_back({
        .asset = ea,
        .var_name = var_name,
        .signature = signature,
        .names = std::move(names)
    });

    return true;
}

static void SortAssets(ManifestGenerator& generator) {
    std::ranges::sort(generator.assets.begin(), generator.assets.end(), [](const AssetEntry& a, const AssetEntry& b) {
        return Compare(a.asset->name->value, b.asset->name->value);
    });
}

bool GenerateAssetManifest(const fs::path& source_path, const fs::path& target_path, Props* config)
{
    (void)target_path;

    if (fs::exists(source_path) && !fs::is_directory(source_path))
        return false;

    ManifestGenerator generator = {};
    generator.source_path = source_path;
    generator.target_path = target_path;
    generator.config = config;

    try
    {
        Enumerate(g_editor.asset_allocator, ReadAsset, &generator);
    }
    catch (const std::exception&)
    {
        return false;
    }

    for (const std::string& name_str : config->GetKeys("names"))
    {
        const Name* name = GetName(name_str.c_str());
        generator.names[name] = GetNameVar(name);
    }

    SortAssets(generator);
    GenerateHeader(generator);
    GenerateSource(generator);
    return true;
}

static void GenerateSource(ManifestGenerator& generator)
{
    Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

    fs::path header_path = generator.target_path;
    header_path.replace_extension(".h");

    WriteCSTR(stream, ASSET_MANIFEST_HEADER);
    WriteCSTR(stream, "#include <noz/noz.h>\n");
    WriteCSTR(stream, "#include \"%s\"\n\n", header_path.filename().string().c_str());

    for (AssetSignature sig : generator.signatures)
    {
        const char* type_name = GetTypeNameFromSignature(sig);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @%s\n", type_name);

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            WriteCSTR(stream, "%s* %s = nullptr;\n", type_name, asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "const Name* NAME_%s = nullptr;\n", kv.second.c_str());

    WriteCSTR(stream,
        "\n"
        "// @path\n");

    for (AssetEntry& asset : generator.assets)
        WriteCSTR(stream, "const Name* PATH_%s = nullptr;\n", asset.var_name.c_str());

    WriteCSTR(stream,
        "\n"
        "// @load\n"
        "bool LoadAssets(Allocator* allocator)\n"
        "{\n");

    WriteCSTR(stream, "    // @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "    NAME_%s = GetName(\"%s\");\n", kv.second.c_str(), kv.first->value);

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "    // @path\n");
    for (AssetEntry& asset : generator.assets)
        WriteCSTR(stream, "    PATH_%s = GetName(\"%s\");\n", asset.var_name.c_str(), asset.asset->name->value);

    for (AssetSignature sig : generator.signatures)
    {
        const char* type_name = GetTypeNameFromSignature(sig);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", type_name);

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            WriteCSTR(stream, "    NOZ_LOAD_%s(allocator, PATH_%s, %s);\n", type_name_upper.c_str(), asset.var_name.c_str(), asset.var_name.c_str());
        }

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    static %s* _%s[] = {\n", type_name, type_name_upper.c_str());

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            WriteCSTR(stream, "        %s,\n", asset.var_name.c_str());
        }

        WriteCSTR(stream, "        nullptr\n");
        WriteCSTR(stream, "    };\n");
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    %s = _%s;\n", type_name_upper.c_str(), type_name_upper.c_str());
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "    return true;\n");
    WriteCSTR(stream, "}\n");

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @unload\n");
    WriteCSTR(stream, "void UnloadAssets()\n");
    WriteCSTR(stream, "{");

    for (AssetSignature sig : generator.signatures)
    {
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", GetTypeNameFromSignature(sig));

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            WriteCSTR(stream, "    Free(%s);\n",asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "}\n");

    WriteCSTR(stream, "\n#ifdef NOZ_EDITOR\n");
    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "void HotloadAsset(const Name* incoming_name, AssetSignature incoming_signature)\n");
    WriteCSTR(stream, "{");

    for (AssetSignature sig : generator.signatures)
    {
        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "    // @%s\n", GetTypeNameFromSignature(sig));

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            std::string type_name_upper = GetTypeNameFromSignature(asset.signature);
            Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

            WriteCSTR(stream, "    NOZ_RELOAD_%s(PATH_%s, %s);\n", type_name_upper.c_str(), asset.var_name.c_str(), asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "}\n");
    WriteCSTR(stream, "\n#endif // NOZ_EDITOR\n");

    SaveStream(stream, generator.target_path);

    Free(stream);
}

static void GenerateHeader(ManifestGenerator& generator)
{
    Stream* stream = CreateStream(ALLOCATOR_DEFAULT, 4096);

    WriteCSTR(stream, ASSET_MANIFEST_HEADER);
    WriteCSTR(stream,
        "#pragma once\n\n"
        "#include <noz/core_assets.h>\n");

    for (AssetSignature sig : generator.signatures)
    {
        const char* type_name = GetTypeNameFromSignature(sig);
        std::string type_name_upper = type_name;
        Uppercase(type_name_upper.data(), (u32)type_name_upper.size());

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @%s\n", type_name);

        for (AssetEntry& asset : generator.assets)
        {
            if (asset.signature != sig)
                continue;

            WriteCSTR(stream, "extern %s* %s;\n", type_name, asset.var_name.c_str());
        }
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "// @name\n");
    for (auto& kv : generator.names)
        WriteCSTR(stream, "extern const Name* NAME_%s;\n", kv.second.c_str());

    if (!generator.bones.empty())
    {
        WriteCSTR(stream, "\n");
        for (BoneIndex& bone_index : generator.bones)
        {
            if (bone_index.index == 0)
                WriteCSTR(stream, "\n// @BONE_%s\n", bone_index.skeleton_name.c_str());

            WriteCSTR(stream, "constexpr int BONE_%s_%s = %d;\n", bone_index.skeleton_name.c_str(), bone_index.name.c_str(), bone_index.index);
        }
    }

    int style_index = 0;
    for (AssetEntry& asset : generator.assets)
    {
        if (asset.signature != ASSET_SIGNATURE_STYLE_SHEET)
            continue;

        char prefix[MAX_NAME_LENGTH];
        Format(prefix, MAX_NAME_LENGTH, "STYLE_%s", asset.asset->name->value);
        Uppercase(prefix, MAX_NAME_LENGTH);

        WriteCSTR(stream, "\n");
        WriteCSTR(stream, "// @%s\n", prefix);

        int name_index = 0;
        for (const Name* name : asset.names)
        {
            char style_name[MAX_NAME_LENGTH];
            Format(style_name, MAX_NAME_LENGTH, "%s_%s", prefix, name->value);
            Uppercase(style_name, MAX_NAME_LENGTH);
            WriteCSTR(stream, "constexpr StyleId %s = {%d,%d};\n", style_name, style_index, name_index++);
        }

        style_index++;
    }

    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "\nextern bool LoadAssets(Allocator* allocator);\n");
    WriteCSTR(stream, "extern void UnloadAssets();\n");
    WriteCSTR(stream, "\n");
    WriteCSTR(stream, "#ifdef NOZ_EDITOR\n");
    WriteCSTR(stream, "extern void HotloadAsset(const Name* incoming_name, AssetSignature incoming_signature);\n");
    WriteCSTR(stream, "#endif\n");

    fs::path header_path = generator.target_path;
    header_path.replace_extension(".h");
    SaveStream(stream, header_path);

    Free(stream);
}

